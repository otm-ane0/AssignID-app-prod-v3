import {
  Account,
  ClientAuthSession,
  Prisma,
  SocialProvider,
} from '@prisma/client'
import prisma from '../provider/prisma'
import { signJwt, verifyJwt } from '../utils/jwt'
import { getInfiniteExpiryMagic, getUnixMilliseconds } from '../utils/token'
import ClientService from './client'
import HttpError from '../utils/httpError'
import { encryptPasscode, verifyPasscode } from '../utils/passwd'
import { sendVerificationEmail } from '../helpers/email_sender'

export default class AccountService {
  static async randomNameGenerator(length: number) {
    let result = ''
    const characters =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
    const charactersLength = characters.length
    for (let i = 0; i < length; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength))
    }
    /**
     * Generate two words from wordlist.txt and merge them while generating the name
     */
    return result
  }

  static async createAccount(input: Prisma.AccountCreateInput) {
    return await prisma.account.create({
      data: input,
    })
  }

  static async updateAccount(id: string, data: any) {
    return await prisma.account.update({
      where: {
        id: id,
      },
      data: data,
    })
  }

  static async generateAssignId() {
    const random = 0
  }

  static async generateJWTAuthToken(accountId: string, secret: string) {
    return signJwt(
      {
        accountId: accountId,
      },
      secret,
      'accessTokenPrivateKey',
      {},
    )
  }

  static async getAuthTokenForAccount(
    accountId: string,
    secret: string,
    sessionId: string,
  ) {
    const tk = await this.generateJWTAuthToken(accountId, secret)
    return `${tk}/${sessionId}`
  }

  static async decodeJWTAuthToken(accessToken: string, clientId: string) {
    const acTkS = accessToken.split('/')
    const realAccessToken = acTkS[0]
    const sessId = acTkS[1]
    const sess = await ClientService.getSessionWithIDAndClient(sessId, clientId)
    if (!sess) {
      return false
    }
    const v = verifyJwt(
      realAccessToken,
      sess.secret,
      'accessTokenPublicKey',
    ) as {
      accountId: string
    }
    // success account id doesn't match with the token one.
    if (sess.accountId !== v.accountId) {
      return false
    }
    return v.accountId
  }

  static async getAccountWithId(id: string) {
    const assignAccount = await prisma.account.findUnique({
      where: {
        id: id,
      },
      select: {
        id: true,
        assignId: true,
        firstName: true,
        familyName: true,
        picture: true,
        connections: {
          select: {
            provider: true,
            providerId: false,
            providerUsername: true,
          },
        },
      },
    })
    console.log('Account ::: ', assignAccount)
    return assignAccount
  }

  static async getAccountWithIdAlsoSelectSocialConnectionId(id: string) {
    const assignAccount = await prisma.account.findUnique({
      where: {
        id: id,
      },
      select: {
        id: true,
        assignId: true,
        firstName: true,
        familyName: true,
        picture: true,
        connections: {
          select: {
            id: true,
            provider: true,
            providerId: false,
            providerUsername: true,
          },
        },
      },
    })
    console.log('Account ::: ', assignAccount)
    return assignAccount
  }

  static async completeSession(id: string, accountId: string) {
    return await prisma.clientAuthSession.update({
      where: {
        id: id,
      },
      data: {
        status: 'Success',
        accountId: accountId,
        updatedAt: getUnixMilliseconds(),
      },
    })
  }

  static async createXAccount(x_user: any, session: ClientAuthSession) {
    let account = await prisma.account.findFirst({
      where: {
        // email: google_user.email,
        connections: {
          some: {
            providerId: x_user.id,
            provider: SocialProvider.Twitter,
          },
        },
      },
    })

    if (!account) {
      const assignId = (await this.randomNameGenerator(11)) + '@aid.com'

      account = await this.createAccount({
        firstName: x_user['name'],
        familyName: x_user['familyName'],
        // email: google_user['email'],
        picture: x_user['picture'], // clone the picture
        assignId: assignId,
        connections: {
          create: {
            provider: SocialProvider.Twitter,
            providerId: x_user.id,
            providerUsername: x_user['email'] || '-1',
            lastUsed: getUnixMilliseconds(),
            connectedAt: getUnixMilliseconds(),
            token: {
              create: {
                accessToken: x_user.accessToken,
                refreshToken: x_user.refreshToken,
                expireAt: getInfiniteExpiryMagic(),
                createdAt: getUnixMilliseconds(),
              },
            },
          },
        },
      })
    }

    const acTk = await this.getAuthTokenForAccount(
      account.id,
      session.secret,
      session.id,
    )

    const accessTk = await prisma.accountAccessToken.create({
      data: {
        clientAuthSessionId: session.id,
        createdAt: getUnixMilliseconds(),
        expireAt: getInfiniteExpiryMagic(),
        isRevoked: false,
        accessToken: acTk,
      },
    })

    await this.completeSession(session.id, account.id)

    return accessTk.accessToken
  }

  static async generateEmailOtpChallenge(user_id: string, user_email: string) {
    let code = await this.randomNameGenerator(6)
    let challenge = await prisma.accountChallenge.create({
      data: {
        nativeAccountId: user_id,
        otpCode: code,
      },
    })
    await sendVerificationEmail(user_email, challenge.id, code)
    return challenge.id
  }

  static async createNativeAccount(
    native_user: any,
    session: ClientAuthSession,
    challenge_type?: string,
  ) {
    // let account = await prisma.account.findFirst({
    //   where: {
    //     connections: {
    //       some: {
    //         providerUsername: native_user.email,
    //         provider: 'Native',
    //       },
    //     },
    //   },
    // })

    console.log("challenge type ;; ", challenge_type)

    if (challenge_type !== 'email') {
      let native_account = await prisma.nativeAccount.findFirst({
        where: {
          userName: native_user.email,
        },
      })

      let encrypted_passwd = await encryptPasscode(native_user.password)

      if (native_account) {
        if (native_account.verified) {
          /** compare the password */
          let compare_result = await verifyPasscode(
            native_user.password,
            native_account.password,
          )
          if (compare_result) {
            
            
            /** check if access token is sent, check if it present in db else send a email verification request */
            let login_cookie = native_user.login_cookie

            let cookie_found_and_valid = false
            /** @todo generate access tokens */

            let ctk = null

            if (login_cookie) {
              ctk = await prisma.nativeAccountAuthCookie.findFirst({
                where: {
                  cookieToken: login_cookie,
                },
              })
            }

            if (ctk && ctk.nativeAccountId === native_account.id) {
              cookie_found_and_valid = true
            }

            if (cookie_found_and_valid) {
              let account = await prisma.account.findFirst({
                where: {
                  connections: {
                    some: {
                      providerId: native_account.id,
                      provider: 'Native',
                    },
                  },
                },
              })

              if (!account) {
                return {
                  message: 'ACCOUNT_NOT_FOUND',
                }
              }

              /** delete used cookie */
              await prisma.nativeAccountAuthCookie.delete({
                where: {
                  id: ctk?.id,
                },
              })

              const acTk = await this.getAuthTokenForAccount(
                account.id,
                session.secret,
                session.id,
              )

              const accessTk = await prisma.accountAccessToken.create({
                data: {
                  clientAuthSessionId: session.id,
                  createdAt: getUnixMilliseconds(),
                  expireAt: getInfiniteExpiryMagic(),
                  isRevoked: false,
                  accessToken: acTk,
                },
              })

              await this.completeSession(session.id, account.id)

              // new cookie token
              let ctoken = await this.randomNameGenerator(20)
              let easy_auth_cookie =
                await prisma.nativeAccountAuthCookie.create({
                  data: {
                    cookieToken: ctoken,
                    nativeAccountId: native_account.id,
                  },
                })

              return {
                message: 'PASSWORD_AUTH_PASSED',
                data: {
                  cookieToken: ctoken,
                  accessToken: accessTk.accessToken,
                },
              }
            } else {
              /** generate otp creds */
              let otp_auth_id = await this.generateEmailOtpChallenge(
                native_account.id,
                native_account.userName,
              )
              return {
                message: 'PASSWORD_AUTH_PASSED_AND_OTP_AUTH_REQUIRED',
                data: {
                  request_id: otp_auth_id,
                },
              }
            }
          } else {
            return {
              message: 'PASSWORD_AUTH_FAIL',
            }
          }
        } else {
          await prisma.nativeAccount.update({
            where: {
              id: native_account.id,
            },
            data: {
              password: encrypted_passwd,
            },
          })

          /** send the verification email */
          let otp_auth_id = await this.generateEmailOtpChallenge(
            native_account.id,
            native_account.userName,
          )

          return {
            message: 'PASSWORD_AUTH_PASSED_AND_OTP_AUTH_REQUIRED',
            data: {
              request_id: otp_auth_id,
            },
          }
        }
      } else {
        native_account = await prisma.nativeAccount.create({
          data: {
            userName: native_user.email,
            password: encrypted_passwd,
            /** disabling verification for now */
            // verified: false,
            verified: true,
          },
        })

        /** disabling verification for now start */
        // /** send the verification email */
        // let otp_auth_id = await this.generateEmailOtpChallenge(
        //   native_account.id,
        //   native_account.userName,
        // )
        // return {
        //   message: 'PASSWORD_AUTH_PASSED_AND_OTP_AUTH_REQUIRED',
        //   data: {
        //     request_id: otp_auth_id,
        //   },
        // }
        /** disabling verification for now end */

        /** enabling otp less signup */
        let account = await prisma.account.findFirst({
          where: {
            connections: {
              some: {
                providerId: native_account.id,
                provider: 'Native',
              },
            },
          },
        })

        if (!account) {
          console.log('ERROR AC NOT FOUND :: ', account)
          return {
            message: 'ACCOUNT_NOT_FOUND',
          }
        }

        const acTk = await this.getAuthTokenForAccount(
          account.id,
          session.secret,
          session.id,
        )

        const accessTk = await prisma.accountAccessToken.create({
          data: {
            clientAuthSessionId: session.id,
            createdAt: getUnixMilliseconds(),
            expireAt: getInfiniteExpiryMagic(),
            isRevoked: false,
            accessToken: acTk,
          },
        })

        await this.completeSession(session.id, account.id)

        let ctoken = await this.randomNameGenerator(20)
        let easy_auth_cookie = await prisma.nativeAccountAuthCookie.create({
          data: {
            cookieToken: ctoken,
            nativeAccountId: native_account.id,
          },
        })

        return {
          message: 'PASSWORD_AUTH_PASSED',
          data: {
            cookieToken: ctoken,
            accessToken: accessTk.accessToken,
          },
        }

        /** enabling otp less signup END */
      }
    } else {
      let native_account = await prisma.nativeAccount.findFirst({
        where: {
          userName: native_user.email,
        },
      })
      if (!native_account) {
        return {
          message: 'ACCOUNT_NOT_FOUND',
        }
      } else {
        let otp_auth_id = await this.generateEmailOtpChallenge(
          native_account.id,
          native_account.userName,
        )

        return {
          message: 'PASSWORD_AUTH_PASSED_AND_OTP_AUTH_REQUIRED',
          data: {
            request_id: otp_auth_id,
          },
        }
      }
    }
  }

  static async verifyNativeAccount(
    data: { request_id: string; otp: string },
    session: ClientAuthSession,
  ) {
    let otp_auth = await prisma.accountChallenge.findFirst({
      where: {
        id: data.request_id,
        otpCode: data.otp,
      },
    })

    console.log('a :: ', otp_auth)

    if (otp_auth) {
      /** @todo check time */
      if (!otp_auth.createdAt) {
        return {
          message: 'EXPIRED',
        }
      }

      let native_account_id = otp_auth.nativeAccountId

      let native_account = await prisma.nativeAccount.findFirst({
        where: {
          id: native_account_id,
        },
      })

      console.log('native account ::: ', native_account)

      await prisma.accountChallenge.delete({
        where: {
          id: otp_auth.id,
        },
      })

      if (!native_account) {
        return {}
      }

      if (native_account.verified === false) {
        await prisma.nativeAccount.update({
          where: {
            id: native_account_id,
          },
          data: {
            verified: true,
          },
        })
      }

      let account = await prisma.account.findFirst({
        where: {
          connections: {
            some: {
              providerId: native_account_id,
              provider: 'Native',
            },
          },
        },
      })

      console.log('account ::: ', account)

      if (!account) {
        const assignId = (await this.randomNameGenerator(11)) + '@aid.com'

        account = await this.createAccount({
          firstName: null,
          familyName: null,
          picture: null, // clone the picture
          assignId: assignId,
          connections: {
            create: {
              provider: 'Native',
              providerId: native_account_id,
              providerUsername: native_account['userName'] || '-1',
              lastUsed: getUnixMilliseconds(),
              connectedAt: getUnixMilliseconds(),
              token: {
                create: {
                  accessToken: 'null',
                  refreshToken: null,
                  expireAt: getInfiniteExpiryMagic(),
                  createdAt: getUnixMilliseconds(),
                },
              },
            },
          },
        })
      }

      const acTk = await this.getAuthTokenForAccount(
        account.id,
        session.secret,
        session.id,
      )

      const accessTk = await prisma.accountAccessToken.create({
        data: {
          clientAuthSessionId: session.id,
          createdAt: getUnixMilliseconds(),
          expireAt: getInfiniteExpiryMagic(),
          isRevoked: false,
          accessToken: acTk,
        },
      })

      await this.completeSession(session.id, account.id)

      let ctoken = await this.randomNameGenerator(20)

      let easy_auth_cookie = await prisma.nativeAccountAuthCookie.create({
        data: {
          cookieToken: ctoken,
          nativeAccountId: native_account_id,
        },
      })

      return {
        message: 'PASSED',
        data: {
          accessToken: accessTk.accessToken,
          cookieToken: ctoken,
          /** a cookie for auth */
        },
      }
    } else {
      return {
        message: 'FAILED',
      }
    }
  }

  static async createFacebookAccount(fb_user: any, session: ClientAuthSession) {
    let account = await prisma.account.findFirst({
      where: {
        // email: google_user.email,
        connections: {
          some: {
            providerId: fb_user.id,
            provider: 'Facebook',
          },
        },
      },
    })

    if (!account) {
      const assignId = (await this.randomNameGenerator(11)) + '@aid.com'

      account = await this.createAccount({
        firstName: fb_user['name'],
        familyName: fb_user['familyName'],
        // email: google_user['email'],
        picture: fb_user['picture'], // clone the picture
        assignId: assignId,
        connections: {
          create: {
            provider: 'Facebook',
            providerId: fb_user.id,
            providerUsername: fb_user['email'] || '-1',
            lastUsed: getUnixMilliseconds(),
            connectedAt: getUnixMilliseconds(),
            token: {
              create: {
                accessToken: fb_user.accessToken,
                refreshToken: fb_user.refreshToken,
                expireAt: getInfiniteExpiryMagic(),
                createdAt: getUnixMilliseconds(),
              },
            },
          },
        },
      })
    }

    const acTk = await this.getAuthTokenForAccount(
      account.id,
      session.secret,
      session.id,
    )

    const accessTk = await prisma.accountAccessToken.create({
      data: {
        clientAuthSessionId: session.id,
        createdAt: getUnixMilliseconds(),
        expireAt: getInfiniteExpiryMagic(),
        isRevoked: false,
        accessToken: acTk,
      },
    })

    await this.completeSession(session.id, account.id)

    return accessTk.accessToken
  }

  static async unlinkSocialAccount(accountId: string, provider: string) {
    const account =
      await AccountService.getAccountWithIdAlsoSelectSocialConnectionId(
        accountId,
      )

    let conn: number | null = null

    /** 1 is requried */
    if (account?.connections.length === 1) {
      return false
    }

    account?.connections.map((c) => {
      if (c.provider === provider) {
        conn = c.id
      }
    })

    if (conn) {
      await prisma.socialConnection.delete({
        where: {
          id: conn,
        },
        include: {
          token: true,
        },
      })
      return true
    } else {
      return false
    }
  }

  static async linkXAccount(x_user: any, session: ClientAuthSession) {
    if (!session.accountId) {
      return {
        error: null,
        success: false,
      }
    }

    const account = await prisma.account.findFirst({
      where: {
        // email: google_user.email,
        connections: {
          some: {
            providerId: x_user.id,
            provider: SocialProvider.Twitter,
          },
        },
      },
    })

    if (account) {
      if (account.id === session.accountId) {
        /** THE SAME USER TRYING TO LINK AGAIN */
        /** update info */
        return {
          error: null,
          success: true,
        }
      } else {
        /** This google account is already linked with some other account */
        // throw new HttpError(400, "AccountAlreadyLinked");
        return {
          error: 'ALREADY_LINKED',
          success: false,
        }
      }
    }

    await prisma.account.update({
      where: {
        id: session.accountId,
      },
      data: {
        connections: {
          create: {
            provider: SocialProvider.Twitter,
            providerId: x_user.id,
            providerUsername: x_user['email'] || '-1',
            lastUsed: getUnixMilliseconds(),
            connectedAt: getUnixMilliseconds(),
            token: {
              create: {
                accessToken: x_user.accessToken,
                refreshToken: x_user.refreshToken,
                expireAt: getInfiniteExpiryMagic(),
                createdAt: getUnixMilliseconds(),
              },
            },
          },
        },
      },
    })

    await this.completeSession(session.id, session.accountId)

    return {
      error: null,
      success: true,
    }
  }

  static async linkFacebookAccount(fb_user: any, session: ClientAuthSession) {
    if (!session.accountId) {
      return {
        error: null,
        success: false,
      }
    }

    const account = await prisma.account.findFirst({
      where: {
        // email: google_user.email,
        connections: {
          some: {
            providerId: fb_user.id,
            provider: 'Facebook',
          },
        },
      },
    })

    if (account) {
      if (account.id === session.accountId) {
        /** THE SAME USER TRYING TO LINK AGAIN */
        /** update info */
        return {
          error: null,
          success: true,
        }
      } else {
        /** This google account is already linked with some other account */
        // throw new HttpError(400, "AccountAlreadyLinked");
        return {
          error: 'ALREADY_LINKED',
          success: false,
        }
      }
    }

    await prisma.account.update({
      where: {
        id: session.accountId,
      },
      data: {
        connections: {
          create: {
            provider: 'Facebook',
            providerId: fb_user.id,
            providerUsername: fb_user['email'] || '-1',
            lastUsed: getUnixMilliseconds(),
            connectedAt: getUnixMilliseconds(),
            token: {
              create: {
                accessToken: fb_user.accessToken,
                refreshToken: fb_user.refreshToken,
                expireAt: getInfiniteExpiryMagic(),
                createdAt: getUnixMilliseconds(),
              },
            },
          },
        },
      },
    })

    await this.completeSession(session.id, session.accountId)

    return {
      error: null,
      success: true,
    }
  }

  static async linkGoogleAccount(google_user: any, session: ClientAuthSession) {
    if (!session.accountId) {
      return {
        error: null,
        success: false,
      }
    }

    const account = await prisma.account.findFirst({
      where: {
        // email: google_user.email,
        connections: {
          some: {
            providerId: google_user.id,
            provider: 'Google',
          },
        },
      },
    })

    if (account) {
      if (account.id === session.accountId) {
        /** THE SAME USER TRYING TO LINK AGAIN */
        /** update info */
        return {
          error: null,
          success: true,
        }
      } else {
        /** This google account is already linked with some other account */
        // throw new HttpError(400, "AccountAlreadyLinked");
        return {
          error: 'ALREADY_LINKED',
          success: false,
        }
      }
    }

    await prisma.account.update({
      where: {
        id: session.accountId,
      },
      data: {
        connections: {
          create: {
            provider: 'Google',
            providerId: google_user.id,
            providerUsername: google_user['email'],
            lastUsed: getUnixMilliseconds(),
            connectedAt: getUnixMilliseconds(),
            token: {
              create: {
                accessToken: google_user.accessToken,
                refreshToken: google_user.refreshToken,
                expireAt: getInfiniteExpiryMagic(),
                createdAt: getUnixMilliseconds(),
              },
            },
          },
        },
      },
    })

    await this.completeSession(session.id, session.accountId)

    return {
      error: null,
      success: true,
    }
  }

  static async createGoogleAccount(
    google_user: any,
    session: ClientAuthSession,
  ) {
    let account = await prisma.account.findFirst({
      where: {
        // email: google_user.email,
        connections: {
          some: {
            providerId: google_user.id,
            provider: 'Google',
          },
        },
      },
    })

    if (!account) {
      const assignId = (await this.randomNameGenerator(11)) + '@aid.com'

      account = await this.createAccount({
        firstName: google_user['name'],
        familyName: google_user['familyName'],
        // email: google_user['email'],
        picture: google_user['picture'], // clone the picture
        assignId: assignId,
        connections: {
          create: {
            provider: 'Google',
            providerId: google_user.id,
            providerUsername: google_user['email'],
            lastUsed: getUnixMilliseconds(),
            connectedAt: getUnixMilliseconds(),
            token: {
              create: {
                accessToken: google_user.accessToken,
                refreshToken: google_user.refreshToken,
                expireAt: getInfiniteExpiryMagic(),
                createdAt: getUnixMilliseconds(),
              },
            },
          },
        },
      })
    }

    const acTk = await this.getAuthTokenForAccount(
      account.id,
      session.secret,
      session.id,
    )

    const accessTk = await prisma.accountAccessToken.create({
      data: {
        clientAuthSessionId: session.id,
        createdAt: getUnixMilliseconds(),
        expireAt: getInfiniteExpiryMagic(),
        isRevoked: false,
        accessToken: acTk,
      },
    })

    await this.completeSession(session.id, account.id)

    return accessTk.accessToken
  }

  static async createSessionHelper(
    val1: string,
    val2: string,
    clientId: string,
    sessionId: string,
  ) {
    return await prisma.sessionHelper.create({
      data: {
        helperVal1: val1,
        helperVal2: val2,
        clientId: clientId,
        sessionId: sessionId,
      },
    })
  }
  static async getSessionHelper(val1: string, val2: string) {
    let data: {
      clientId: string
      sessionId: string
    } | null = null
    const s = await prisma.sessionHelper.findUnique({
      where: {
        helperVal1: val1,
      },
    })
    if (s && s.helperVal2 === val2) {
      data = {
        clientId: s.clientId,
        sessionId: s.sessionId,
      }
      await prisma.sessionHelper.delete({
        where: {
          id: s.id,
        },
      })
    }
    return data
  }
}
